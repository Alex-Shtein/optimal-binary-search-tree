
# Оптимальное двоичное дерево поиска (OBST)

Реализация шаблонного класса оптимального двоичного дерева поиска (Optimal Binary Search Tree) на C++. Алгоритм строит дерево с минимальной средней стоимостью поиска, учитывая вероятности успешного и неудачного поиска элементов.

## Особенности реализации

- **Шаблонный класс**: Работает с любыми типами данных, поддерживающими сравнение
- **Оптимальное построение**: Минимизирует среднее время доступа к элементам
- **Динамическое программирование**: Использует матричный метод для построения оптимального дерева
- **Визуализация**: Возможность вывода структуры дерева в консоль

## Основные методы

```cpp
// Конструктор с параметрами
OptimalBinarySearchTree(T* arr, int* success, int* failure, int size);

// Вставка элемента
bool Insert(const T& value);

// Проверка наличия элемента
bool Contains(const T& value);

// Проверка на пустоту
bool Empty() const;

// Обход дерева (корень-левый-правый)
std::vector<T> RoundRootLR();

// Вывод дерева в консоль
void Output();
```

## Пример использования

```cpp
int keys[] = {1, 2, 3, 4};
int success_probs[] = {0, 5, 4, 1, 7}; // Вероятности успешного поиска
int failure_probs[] = {3, 8, 2, 9, 6}; // Вероятности неудачного поиска

OptimalBinarySearchTree<int> tree(keys, success_probs, failure_probs, 4);

// Проверка наличия элемента
if (tree.Contains(3)) {
    // Элемент найден
}

// Обход дерева
auto traversal = tree.RoundRootLR();

// Визуализация дерева
tree.Output();
```

## Тестирование

Проект включает набор тестов с использованием Google Test:

1. **Базовые тесты**:
   - Проверка корректности построения дерева
   - Проверка обхода RoundRootLR
   - Проверка работы с различными входными данными

2. **Примеры тестовых случаев**:
   - Разные распределения вероятностей
   - Различные размеры входных данных
   - Граничные случаи

### Запуск тестов

```bash
mkdir build
cd build
cmake ..
make
./tests/OptimalBinarySearchTreeTests
```

## Требования

- Компилятор C++ с поддержкой C++11
- CMake (рекомендуется)
- Google Test (уже включен в проект)

## Алгоритм построения

1. Инициализация матриц R, W и P
2. Заполнение матрицы весов W
3. Поиск оптимального корня для каждого поддерева
4. Рекурсивное построение дерева на основе матрицы R

## Визуализация вывода

Метод `Output()` выводит дерево в консоль в виде:

```
     11
  9
     7
5
     4
  3
     2
```